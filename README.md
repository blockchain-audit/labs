# Hack


## Cycles

* Tokenomics
* Finance
* Modeling
* Business Requirements
* Formal Specification
* Implementation [high level]
* Optimization [low level]
* Unit Test
* Fuzz Test
* Symbolic Test
* Security Audit
* Formal verification [economical vulnerabilities]

### Explore

* Manually copying code
* Annotating it with personal understanding and context
* Add questions
* Compare to other known languages

1. **Active Learning**: Manual transcription of code requires active engagement with the material. By physically writing or typing out the code, programmers reinforce their understanding of syntax, structure, and logic, promoting deeper learning and retention.

2. **Clarification of Concepts**: Annotating the copied code allows programmers to articulate their understanding of the code's purpose, functionality, and underlying concepts. This process clarifies ambiguous or complex areas, helping to solidify comprehension and identify gaps in knowledge.

3. **Contextualization**: Adding contextual information alongside the code-such as project requirements, design considerations, or relevant background knowledge-provides valuable context for future reference. Understanding the broader context in which the code operates enhances comprehension and facilitates informed decision-making.

4. **Identification of Patterns**: Manual copying and annotation enable programmers to identify recurring patterns, idioms, or design principles present in the code. Recognizing these patterns promotes code reuse, fosters good coding practices, and accelerates learning by internalizing common programming constructs.

5. **Reflection and Self-Assessment**: Annotation prompts programmers to reflect on their understanding of the code and evaluate their proficiency. By articulating their thoughts, insights, and questions, programmers can assess their grasp of the material and identify areas for further study or improvement.

6. **Active Problem-Solving**: Annotating code with questions and uncertainties encourages active problem-solving and inquiry. Programmers may pose questions about specific lines of code, algorithmic choices, or potential optimizations, stimulating critical thinking and curiosity-driven exploration.

7. **Documentation and Knowledge Sharing**: Annotated code serves as a personalized learning resource and reference material. By documenting their insights, interpretations, and inquiries, programmers create a repository of knowledge that can be revisited, shared with peers, or used for self-study purposes.

8. **Collaboration and Feedback**: Sharing annotated code with peers or mentors facilitates collaborative learning and feedback exchange. Peers can review annotations, provide insights, offer explanations, or suggest alternative approaches, enriching the learning experience and fostering a culture of continuous improvement.

9. **Error Recognition and Debugging**: Annotating code while copying it may highlight discrepancies or errors in understanding. If the annotated understanding deviates from the original code's intended functionality, programmers can identify misunderstandings or misconceptions that require clarification or correction.

10. **Preparation for Real-World Challenges**: Manual transcription and annotation simulate real-world scenarios where programmers must comprehend, modify, or extend existing codebases. Practicing this skill enhances readiness for professional software development roles, where code comprehension and modification are routine tasks.

### Interact

* Creating tests to enable learning
* Focusing on getting deep into the mechanisms
* Add edge cases

1. **Understanding Requirements**: When programmers create test scenarios, they must first understand the requirements and expected behavior of the software. This process encourages thorough exploration of the problem domain, leading to a deeper understanding of the project's objectives and constraints.

2. **Hands-on Application of Concepts**: Writing test scenarios requires applying programming concepts and techniques in practical contexts. This hands-on experience reinforces learning by allowing programmers to directly engage with the material and see how theoretical concepts translate into real-world code.

3. **Feedback Loop for Learning**: Test-driven development (TDD) practices emphasize writing tests before implementing code. This approach creates a continuous feedback loop that supports iterative learning. Programmers write tests based on requirements, implement code to satisfy those tests, and then refine both the tests and code as their understanding deepens.

4. **Identification of Edge Cases**: Writing test scenarios encourages programmers to consider edge cases and boundary conditions that may not be immediately obvious. Exploring these scenarios fosters a more comprehensive understanding of the problem space and helps uncover nuances and complexities that may impact the software's behavior.

5. **Debugging Skills**: When tests fail, programmers must diagnose and debug the underlying issues. This process sharpens their debugging skills as they analyze failures, trace code execution paths, and identify root causes. Through repeated exposure to debugging challenges, programmers gain proficiency in troubleshooting and problem-solving.

6. **Encourages Modular Design**: Test scenarios promote modular code design by encouraging programmers to write tests for individual functions, methods, or components. This modular approach fosters code reusability, maintainability, and scalability—all essential principles for effective software development.

7. **Documentation and Knowledge Sharing**: Well-written test scenarios serve as documentation that communicates the intended behavior and usage of code components. As programmers create tests, they articulate assumptions, constraints, and dependencies, which aids in knowledge sharing within the development team and beyond.

8. **Experimentation and Exploration**: Writing tests allows programmers to experiment with different approaches and solutions. They can explore alternative design patterns, algorithms, or libraries within the controlled environment of test scenarios, facilitating experiential learning and discovery.

9. **Cultivates Confidence**: Successfully passing tests validates programmers' understanding and implementation of the desired functionality. This validation builds confidence in their skills and abilities, encouraging continued exploration and learning in increasingly complex domains.

10. **Community Engagement and Collaboration**: Test-driven development practices are widely adopted in software development communities. Engaging in discussions, code reviews, and collaborative projects involving tests provides opportunities for peer learning, feedback, and knowledge exchange, enriching the learning experience.

### Edge Scenarios

Creating edge scenarios—situations that push the boundaries or test the extremes within a field of knowledge—can offer several advantages for learning:

1. **Deeper Understanding**: Edge scenarios challenge conventional thinking and force learners to explore the outer limits of their knowledge. By grappling with these scenarios, learners gain a deeper understanding of the principles and concepts involved.

2. **Critical Thinking**: Edge scenarios encourage critical thinking by requiring learners to analyze complex situations, identify potential pitfalls, and devise innovative solutions. This process fosters the development of analytical skills essential for success in any field.

3. **Problem-Solving Skills**: Engaging with edge scenarios hones problem-solving skills as learners confront unique challenges that may not have straightforward solutions. This fosters creativity and adaptability, key attributes in navigating real-world complexities.

4. **Preparation for Unforeseen Circumstances**: Edge scenarios prepare learners to handle unexpected situations or crises that may arise in their field. By exposing themselves to extreme or unlikely scenarios, learners become better equipped to respond effectively to novel challenges.

5. **Risk Management**: Understanding edge scenarios helps learners assess risks more effectively and develop strategies to mitigate them. This is particularly valuable in fields where decision-making under uncertainty is common, such as finance, engineering, or healthcare.

6. **Innovation and Discovery**: Edge scenarios often serve as catalysts for innovation and discovery. By pushing the boundaries of current knowledge, learners may uncover new insights, technologies, or methodologies that can revolutionize their field.

7. **Enhanced Resilience**: Confronting edge scenarios builds resilience by exposing learners to failure and adversity in a controlled environment. This helps develop the emotional fortitude necessary to persevere in the face of setbacks and challenges.

8. **Cross-Disciplinary Insights**: Edge scenarios encourage learners to draw upon knowledge from diverse disciplines to address complex problems. This interdisciplinary approach fosters creativity and allows for the synthesis of ideas from different fields, leading to novel solutions.

9. **Continuous Learning and Improvement**: By exploring edge scenarios, learners embrace a mindset of continuous learning and improvement. They recognize that there is always more to discover and understand, motivating them to remain curious and open to new ideas throughout their careers.


### Approach Impossible Problems

When faced with a problem for which you have no idea where to start, here are some initial steps to help you navigate the situation:

1. **Define the Problem**: Begin by clearly articulating and understanding the problem you're trying to solve. Break it down into manageable components and identify any constraints or requirements.

2. **Research and Gather Information**: Conduct research to gather information relevant to the problem. Explore existing solutions, similar problems, relevant literature, or online resources that might provide insights or inspiration.

3. **Brainstorm Possible Approaches**: Engage in brainstorming to generate potential approaches or strategies for solving the problem. Encourage creativity and open-mindedness, considering both conventional and unconventional ideas.

4. **Identify Assumptions and Unknowns**: Recognize any assumptions you're making about the problem and challenge them. Identify unknowns or uncertainties that need clarification and determine how to address them.

5. **Seek Guidance or Collaboration**: Don't hesitate to seek guidance or collaborate with others who may have expertise or experience relevant to the problem. Reach out to mentors, colleagues, or online communities for advice, feedback, or assistance.

6. **Break It Down**: If the problem seems overwhelming, break it down into smaller, more manageable tasks or sub-problems. Focus on tackling one aspect at a time, gradually building momentum and understanding.

7. **Start Somewhere**: Choose a starting point, even if it's uncertain or arbitrary. Taking action, however small, can help overcome inertia and stimulate progress. Remember that initial attempts may not yield perfect solutions but can provide valuable learning experiences.

8. **Experiment and Iterate**: Be willing to experiment with different approaches, techniques, or tools. Embrace a mindset of iteration, where you learn from each attempt and refine your approach based on feedback and results.

9. **Keep an Open Mind**: Remain open to new perspectives, insights, and solutions that may emerge during the problem-solving process. Be willing to pivot or adapt your approach based on new information or changing circumstances.

10. **Persist and Adapt**: Persistence is key when facing challenges without clear solutions. Stay determined and resilient, persevering through setbacks and obstacles. Be prepared to adapt your strategy as needed, learning from failures and adjusting your approach accordingly.

By following these initial steps and maintaining a proactive and flexible approach, you can effectively navigate complex problems even when you're unsure where to start.



## Math

* Duo
* Algebra 12
* Brilliant
* Logicola
* Lean4

## Landing
- my history
- bounty opportunity
- intro blockchain [bank IT vs public network]
- why neovim  [kosher + velocity - learning curve]

### EVM

* [lean4-evm](https://github.com/DavePearce/LeanEVM/tree/main)

### Skills

* EVM opcodes
* Solidity
* Dafny
* Tokenomics
* Attack Vectors
* Oracle
* Huff
* Logic
* Testing [unit, fuzz, static, certora]
* ZK
* Tokenomics
* Math
* Finance
* Accounting
* Design Patterns
* Nodes
* Networks,

### Project

* White Paper
* User Stories
* Full Vector attacks audit
* Economical Audit [Dafny]


### Audit

We focus on economical attacks on invariants, once manual checks are done by AI pattern matching.

* Review manually all the attack vectors per function
* Map Properties and Invariants
* Write formals specs per function
* Implement  spces and functions in Dafny



## Environment

* [git](https://phoenixnap.com/kb/how-to-install-git-on-ubuntu)
* [zsh](https://phoenixnap.com/kb/install-zsh-ubuntu)
* [lean4](https://leanprover-community.github.io/install/linux.html)
* [nix](https://nixos.org/download) - install single user with --no-daemon
* [vscode](https://code.visualstudio.com/)
* [rust](https://www.rust-lang.org/tools/install)
* [golang](https://go.dev/doc/install)
* [foundry](https://book.getfoundry.sh/getting-started/installation)
* [huff](https://docs.huff.sh/get-started/installing/)


## Tools

* [evm-analytics](https://github.com/Jon-Becker/heimdall-rs)


```
ext tintinweb.solidity-visual-auditor
ext install huff-language.huff-language
ext install dafny-lang.ide-vscode
ext install golang.Go
```

## Daily Project

* [erc-20](https://eips.ethereum.org/EIPS/eip-20)
* [multi-token](https://eips.ethereum.org/EIPS/eip-1155)
* [minimal-proxy](https://eips.ethereum.org/EIPS/eip-1167)



## Routine

### Math

* Algebra
* Schoolyourself
* Brilliant
* Logicola
* Lean4


### Project

* Detail and discuss specs
* Implement [erc20, erc 721, vault, staking, farm, dao, CDP, amm]


### Coding
* Solidity
* Huff


### Audit

* Dafny
* Attack Vectors
* Protocol Mechanisms


## Folders

* huff  - huff tutorial
* dafny - dafny tutorial
* src   - [solidity, huff and dafny]





## Getting Started

### Requirements

The following will need to be installed in order to use this template. Please follow the links and instructions.

-   [Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git)
    -   You'll know you've done it right if you can run `git --version`
-   [Foundry / Foundryup](https://github.com/gakonst/foundry)
    -   This will install `forge`, `cast`, and `anvil`
    -   You can test you've installed them right by running `forge --version` and get an output like: `forge 0.2.0 (92f8951 2022-08-06T00:09:32.96582Z)`
    -   To get the latest of each, just run `foundryup`
-   [Huff Compiler](https://docs.huff.sh/get-started/installing/)
    -   You'll know you've done it right if you can run `huffc --version` and get an output like: `huffc 0.3.0`

### Quickstart

1. Clone this repo or use template

Click "Use this template" on [GitHub](https://github.com/huff-language/huff-project-template) to create a new repository with this repo as the initial state.

Or run:

```
git clone https://github.com/huff-language/huff-project-template
cd huff-project-template
```

2. Install dependencies

Once you've cloned and entered into your repository, you need to install the necessary dependencies. In order to do so, simply run:

```shell
forge install
```

3. Build & Test

To build and test your contracts, you can run:

```shell
forge build
forge test
```

For more information on how to use Foundry, check out the [Foundry Github Repository](https://github.com/foundry-rs/foundry/tree/master/forge) and the [foundry-huff library repository](https://github.com/huff-language/foundry-huff).


## Blueprint

```ml
lib
├─ forge-std — https://github.com/foundry-rs/forge-std
├─ foundry-huff — https://github.com/huff-language/foundry-huff
scripts
├─ Deploy.s.sol — Deployment Script
src
├─ SimpleStore — A Simple Storage Contract in Huff
test
└─ SimpleStore.t — SimpleStoreTests
```


## License

[The Unlicense](https://github.com/huff-language/huff-project-template/blob/master/LICENSE)


## Acknowledgements

- [forge-template](https://github.com/foundry-rs/forge-template)
- [femplate](https://github.com/abigger87/femplate)


## Disclaimer

_These smart contracts are being provided as is. No guarantee, representation or warranty is being made, express or implied, as to the safety or correctness of the user interface or the smart contracts. They have not been audited and as such there can be no assurance they will work as intended, and users may experience delays, failures, errors, omissions, loss of transmitted information or loss of funds. The creators are not liable for any of the foregoing. Users should proceed with caution and use at their own risk._
